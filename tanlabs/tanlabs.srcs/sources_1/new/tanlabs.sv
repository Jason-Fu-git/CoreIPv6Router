`timescale 1ns / 1ps

/* Tsinghua Advanced Networking Labs */
`include "frame_datapath.vh"
module tanlabs #(
    parameter SIM = 0
) (
    input wire RST,

    input wire gtclk_125_p,
    input wire gtclk_125_n,

    output wire [15:0] led,

    output wire uart_tx,
    input  wire uart_rx,

    // add buttons and switches
    input wire [ 3:0] touch_btn,
    input wire [15:0] dip_sw,

    // SFP:
    // +-+-+
    // |0|2|
    // +-+-+
    // |1|3|
    // +-+-+
    input  wire [3:0] sfp_rx_los,
    input  wire [3:0] sfp_rx_p,
    input  wire [3:0] sfp_rx_n,
    output wire [3:0] sfp_tx_dis,
    output wire [3:0] sfp_tx_p,
    output wire [3:0] sfp_tx_n,
    output wire [3:0] sfp_link,
    output wire [3:0] sfp_act,

    // I2C for SFP, unused.
    input wire sfp_sda,
    input wire sfp_scl,

    // SODIMM.
    inout [63:0] ddr3_dq,
    inout [ 7:0] ddr3_dqs_n,
    inout [ 7:0] ddr3_dqs_p,

    output [15:0] ddr3_addr,
    output [2:0] ddr3_ba,
    output ddr3_ras_n,
    output ddr3_cas_n,
    output ddr3_we_n,
    output ddr3_reset_n,
    output [0:0] ddr3_ck_p,
    output [0:0] ddr3_ck_n,
    output [0:0] ddr3_cke,
    output [0:0] ddr3_cs_n,
    output [7:0] ddr3_dm,
    output [0:0] ddr3_odt,

    // Base RAM.
    inout wire [31:0] base_ram_data,
    output wire [20:0] base_ram_addr,
    output wire [3:0] base_ram_be_n,
    output wire base_ram_ce_n,
    output wire base_ram_oe_n,
    output wire base_ram_we_n
);

  // added ip addr and valid
  wire [3:0][127:0] ip_addrs;
  wire [3:0][ 47:0] mac_addrs;

  localparam DATA_WIDTH = 64;
  localparam ID_WIDTH = 3;

  wire [4:0] debug_ingress_interconnect_ready;
  wire debug_datapath_fifo_ready;
  wire debug_egress_interconnect_ready;

  wire reset_in = RST;
  wire locked0, locked1;
  wire gtref_clk;  // 125MHz for the PHY/MAC IP core
  wire ref_clk;  // 200MHz for the PHY/MAC IP core
  wire mig_clk;  // 250MHz for the DRAM controller

  clk_wiz_0 clk_wiz_0_i (
      .ref_clk_out(ref_clk),
      .mig_clk_out(mig_clk),
      .reset(1'b0),
      .locked(locked0),
      .clk_in1(gtref_clk)
  );

  wire core_clk;  // 50MHz for the CPU
  wire reset_core;  // reset for the CPU

  assign core_clk   = eth_clk;
  assign reset_core = reset_eth;
  wire reset_not_sync = reset_in || !locked0;

  //   clk_wiz_1 clk_wiz_1_i (
  //       .core_clk_out(core_clk),
  //       .reset(1'b0),
  //       .locked(locked1),
  //       .clk_in1(gtref_clk)
  //   );

  //   wire reset_not_sync = reset_in || !locked0 || !locked1;  // reset components


  //   reset_sync reset_sync_reset_core (
  //       .clk(core_clk),
  //       .i  (reset_not_sync),
  //       .o  (reset_core)
  //   );

  wire mmcm_locked_out;
  wire rxuserclk_out;
  wire rxuserclk2_out;
  wire userclk_out;
  wire userclk2_out;
  wire pma_reset_out;
  wire gt0_qplloutclk_out;
  wire gt0_qplloutrefclk_out;
  wire gtref_clk_out;
  wire gtref_clk_buf_out;

  assign gtref_clk = gtref_clk_buf_out;
  wire eth_clk = userclk2_out;  // README: This is the main clock for frame processing logic,
  // 125MHz generated by the PHY/MAC IP core. 8 AXI-Streams are in this clock domain.

  wire reset_eth_not_sync = reset_in || !mmcm_locked_out;
  wire reset_eth;
  reset_sync reset_sync_reset_eth (
      .clk(eth_clk),
      .i  (reset_eth_not_sync),
      .o  (reset_eth)
  );

  wire [7:0] eth_tx8_data[0:4];
  wire eth_tx8_last[0:4];
  wire eth_tx8_ready[0:4];
  wire eth_tx8_user[0:4];
  wire eth_tx8_valid[0:4];

  wire [7:0] eth_rx8_data[0:4];
  wire eth_rx8_last[0:4];
  wire eth_rx8_user[0:4];
  wire eth_rx8_valid[0:4];

  genvar i;
  generate
    if (!SIM) begin : phy_mac_ip_cores
      // Instantiate 4 PHY/MAC IP cores.

      assign sfp_tx_dis[0] = 1'b0;
      axi_ethernet_0 axi_ethernet_0_i (
          .mac_irq(),
          .tx_mac_aclk(),
          .rx_mac_aclk(),
          .tx_reset(),
          .rx_reset(),

          .glbl_rst(reset_not_sync),

          .mmcm_locked_out(mmcm_locked_out),
          .rxuserclk_out(rxuserclk_out),
          .rxuserclk2_out(rxuserclk2_out),
          .userclk_out(userclk_out),
          .userclk2_out(userclk2_out),
          .pma_reset_out(pma_reset_out),
          .gt0_qplloutclk_out(gt0_qplloutclk_out),
          .gt0_qplloutrefclk_out(gt0_qplloutrefclk_out),
          .gtref_clk_out(gtref_clk_out),
          .gtref_clk_buf_out(gtref_clk_buf_out),

          .ref_clk(ref_clk),

          .s_axi_lite_resetn(~reset_eth),
          .s_axi_lite_clk(eth_clk),
          .s_axi_araddr(0),
          .s_axi_arready(),
          .s_axi_arvalid(0),
          .s_axi_awaddr(0),
          .s_axi_awready(),
          .s_axi_awvalid(0),
          .s_axi_bready(0),
          .s_axi_bresp(),
          .s_axi_bvalid(),
          .s_axi_rdata(),
          .s_axi_rready(0),
          .s_axi_rresp(),
          .s_axi_rvalid(),
          .s_axi_wdata(0),
          .s_axi_wready(),
          .s_axi_wvalid(0),

          .s_axis_tx_tdata (eth_tx8_data[0]),
          .s_axis_tx_tlast (eth_tx8_last[0]),
          .s_axis_tx_tready(eth_tx8_ready[0]),
          .s_axis_tx_tuser (eth_tx8_user[0]),
          .s_axis_tx_tvalid(eth_tx8_valid[0]),

          .m_axis_rx_tdata (eth_rx8_data[0]),
          .m_axis_rx_tlast (eth_rx8_last[0]),
          .m_axis_rx_tuser (eth_rx8_user[0]),
          .m_axis_rx_tvalid(eth_rx8_valid[0]),

          .s_axis_pause_tdata (0),
          .s_axis_pause_tvalid(0),

          .rx_statistics_statistics_data (),
          .rx_statistics_statistics_valid(),
          .tx_statistics_statistics_data (),
          .tx_statistics_statistics_valid(),

          .tx_ifg_delay (8'h00),
          .status_vector(),
          .signal_detect(~sfp_rx_los[0]),

          .sfp_rxn(sfp_rx_n[0]),
          .sfp_rxp(sfp_rx_p[0]),
          .sfp_txn(sfp_tx_n[0]),
          .sfp_txp(sfp_tx_p[0]),

          .mgt_clk_clk_n(gtclk_125_n),
          .mgt_clk_clk_p(gtclk_125_p)
      );

      for (i = 1; i < 4; i = i + 1) begin
        assign sfp_tx_dis[i] = 1'b0;
        axi_ethernet_noshared axi_ethernet_noshared_i (
            .mac_irq(),
            .tx_mac_aclk(),
            .rx_mac_aclk(),
            .tx_reset(),
            .rx_reset(),

            .glbl_rst(reset_not_sync),

            .mmcm_locked(mmcm_locked_out),
            .mmcm_reset_out(),
            .rxuserclk(rxuserclk_out),
            .rxuserclk2(rxuserclk2_out),
            .userclk(userclk_out),
            .userclk2(userclk2_out),
            .pma_reset(pma_reset_out),
            .rxoutclk(),
            .txoutclk(),
            .gt0_qplloutclk_in(gt0_qplloutclk_out),
            .gt0_qplloutrefclk_in(gt0_qplloutrefclk_out),
            .gtref_clk(gtref_clk_out),
            .gtref_clk_buf(gtref_clk_buf_out),

            .ref_clk(ref_clk),

            .s_axi_lite_resetn(~reset_eth),
            .s_axi_lite_clk(eth_clk),
            .s_axi_araddr(0),
            .s_axi_arready(),
            .s_axi_arvalid(0),
            .s_axi_awaddr(0),
            .s_axi_awready(),
            .s_axi_awvalid(0),
            .s_axi_bready(0),
            .s_axi_bresp(),
            .s_axi_bvalid(),
            .s_axi_rdata(),
            .s_axi_rready(0),
            .s_axi_rresp(),
            .s_axi_rvalid(),
            .s_axi_wdata(0),
            .s_axi_wready(),
            .s_axi_wvalid(0),

            .s_axis_tx_tdata (eth_tx8_data[i]),
            .s_axis_tx_tlast (eth_tx8_last[i]),
            .s_axis_tx_tready(eth_tx8_ready[i]),
            .s_axis_tx_tuser (eth_tx8_user[i]),
            .s_axis_tx_tvalid(eth_tx8_valid[i]),

            .m_axis_rx_tdata (eth_rx8_data[i]),
            .m_axis_rx_tlast (eth_rx8_last[i]),
            .m_axis_rx_tuser (eth_rx8_user[i]),
            .m_axis_rx_tvalid(eth_rx8_valid[i]),

            .s_axis_pause_tdata (0),
            .s_axis_pause_tvalid(0),

            .rx_statistics_statistics_data (),
            .rx_statistics_statistics_valid(),
            .tx_statistics_statistics_data (),
            .tx_statistics_statistics_valid(),

            .tx_ifg_delay (8'h00),
            .status_vector(),
            .signal_detect(~sfp_rx_los[i]),

            .sfp_rxn(sfp_rx_n[i]),
            .sfp_rxp(sfp_rx_p[i]),
            .sfp_txn(sfp_tx_n[i]),
            .sfp_txp(sfp_tx_p[i])
        );
      end
    end else begin : axis_models
      // For simulation.
      assign gtref_clk_buf_out = gtclk_125_p;
      assign userclk2_out = gtclk_125_p;
      assign mmcm_locked_out = 1'b1;

      assign sfp_tx_dis = 0;
      assign sfp_tx_p = 0;
      assign sfp_tx_n = 0;

      wire [DATA_WIDTH - 1:0] in_data;
      wire [DATA_WIDTH / 8 - 1:0] in_keep;
      wire in_last;
      wire [DATA_WIDTH / 8 - 1:0] in_user;
      wire [ID_WIDTH - 1:0] in_id;
      wire in_valid;
      wire in_ready;

      axis_model axis_model_i (
          .clk  (eth_clk),
          .reset(reset_eth),

          .m_data(in_data),
          .m_keep(in_keep),
          .m_last(in_last),
          .m_user(in_user),
          .m_id(in_id),
          .m_valid(in_valid),
          .m_ready(in_ready)
      );

      wire [DATA_WIDTH - 1:0] sim_tx_data[0:3];
      wire [DATA_WIDTH / 8 - 1:0] sim_tx_keep[0:3];
      wire sim_tx_last[0:3];
      wire sim_tx_ready[0:3];
      wire [DATA_WIDTH / 8 - 1:0] sim_tx_user[0:3];
      wire sim_tx_valid[0:3];

      axis_interconnect_egress axis_interconnect_sim_in_i (
          .ACLK(eth_clk),
          .ARESETN(~reset_eth),

          .S00_AXIS_ACLK(eth_clk),
          .S00_AXIS_ARESETN(~reset_eth),
          .S00_AXIS_TVALID(in_valid),
          .S00_AXIS_TREADY(in_ready),
          .S00_AXIS_TDATA(in_data),
          .S00_AXIS_TKEEP(in_keep),
          .S00_AXIS_TLAST(in_last),
          .S00_AXIS_TDEST(in_id),
          .S00_AXIS_TUSER(in_user),

          .M00_AXIS_ACLK(eth_clk),
          .M00_AXIS_ARESETN(~reset_eth),
          .M00_AXIS_TVALID(sim_tx_valid[0]),
          .M00_AXIS_TREADY(sim_tx_ready[0]),
          .M00_AXIS_TDATA(sim_tx_data[0]),
          .M00_AXIS_TKEEP(sim_tx_keep[0]),
          .M00_AXIS_TLAST(sim_tx_last[0]),
          .M00_AXIS_TDEST(),
          .M00_AXIS_TUSER(sim_tx_user[0]),

          .M01_AXIS_ACLK(eth_clk),
          .M01_AXIS_ARESETN(~reset_eth),
          .M01_AXIS_TVALID(sim_tx_valid[1]),
          .M01_AXIS_TREADY(sim_tx_ready[1]),
          .M01_AXIS_TDATA(sim_tx_data[1]),
          .M01_AXIS_TKEEP(sim_tx_keep[1]),
          .M01_AXIS_TLAST(sim_tx_last[1]),
          .M01_AXIS_TDEST(),
          .M01_AXIS_TUSER(sim_tx_user[1]),

          .M02_AXIS_ACLK(eth_clk),
          .M02_AXIS_ARESETN(~reset_eth),
          .M02_AXIS_TVALID(sim_tx_valid[2]),
          .M02_AXIS_TREADY(sim_tx_ready[2]),
          .M02_AXIS_TDATA(sim_tx_data[2]),
          .M02_AXIS_TKEEP(sim_tx_keep[2]),
          .M02_AXIS_TLAST(sim_tx_last[2]),
          .M02_AXIS_TDEST(),
          .M02_AXIS_TUSER(sim_tx_user[2]),

          .M03_AXIS_ACLK(eth_clk),
          .M03_AXIS_ARESETN(~reset_eth),
          .M03_AXIS_TVALID(sim_tx_valid[3]),
          .M03_AXIS_TREADY(sim_tx_ready[3]),
          .M03_AXIS_TDATA(sim_tx_data[3]),
          .M03_AXIS_TKEEP(sim_tx_keep[3]),
          .M03_AXIS_TLAST(sim_tx_last[3]),
          .M03_AXIS_TDEST(),
          .M03_AXIS_TUSER(sim_tx_user[3]),

          .M04_AXIS_ACLK(eth_clk),
          .M04_AXIS_ARESETN(~reset_eth),
          .M04_AXIS_TVALID(),
          .M04_AXIS_TREADY(1'b1),
          .M04_AXIS_TDATA(),
          .M04_AXIS_TKEEP(),
          .M04_AXIS_TLAST(),
          .M04_AXIS_TDEST(),
          .M04_AXIS_TUSER(),

          .S00_DECODE_ERR()
      );

      for (i = 0; i < 4; i = i + 1) begin
        axis_dwidth_converter_64_8 axis_dwidth_converter_64_8_i (
            .aclk(eth_clk),
            .aresetn(~reset_eth),

            .s_axis_tvalid(sim_tx_valid[i]),
            .s_axis_tready(sim_tx_ready[i]),
            .s_axis_tdata (sim_tx_data[i]),
            .s_axis_tkeep (sim_tx_keep[i]),
            .s_axis_tlast (sim_tx_last[i]),
            .s_axis_tuser (sim_tx_user[i]),

            .m_axis_tvalid(eth_rx8_valid[i]),
            .m_axis_tready(debug_ingress_interconnect_ready[i]),  // FIXME
            .m_axis_tdata (eth_rx8_data[i]),
            .m_axis_tkeep (),
            .m_axis_tlast (eth_rx8_last[i]),
            .m_axis_tuser (eth_rx8_user[i])
        );
      end

      wire [DATA_WIDTH - 1:0] out_data;
      wire [DATA_WIDTH / 8 - 1:0] out_keep;
      wire out_last;
      wire [DATA_WIDTH / 8 - 1:0] out_user;
      wire [ID_WIDTH - 1:0] out_dest;
      wire out_valid;
      wire out_ready;

      axis_interconnect_ingress axis_interconnect_sim_out_i (
          .ACLK(eth_clk),
          .ARESETN(~reset_eth),

          .S00_AXIS_ACLK(eth_clk),
          .S00_AXIS_ARESETN(~reset_eth),
          .S00_AXIS_TVALID(eth_tx8_valid[0]),
          .S00_AXIS_TREADY(eth_tx8_ready[0]),
          .S00_AXIS_TDATA(eth_tx8_data[0]),
          .S00_AXIS_TKEEP(1'b1),
          .S00_AXIS_TLAST(eth_tx8_last[0]),
          .S00_AXIS_TID(3'd0),
          .S00_AXIS_TUSER(eth_tx8_user[0]),

          .S01_AXIS_ACLK(eth_clk),
          .S01_AXIS_ARESETN(~reset_eth),
          .S01_AXIS_TVALID(eth_tx8_valid[1]),
          .S01_AXIS_TREADY(eth_tx8_ready[1]),
          .S01_AXIS_TDATA(eth_tx8_data[1]),
          .S01_AXIS_TKEEP(1'b1),
          .S01_AXIS_TLAST(eth_tx8_last[1]),
          .S01_AXIS_TID(3'd1),
          .S01_AXIS_TUSER(eth_tx8_user[1]),

          .S02_AXIS_ACLK(eth_clk),
          .S02_AXIS_ARESETN(~reset_eth),
          .S02_AXIS_TVALID(eth_tx8_valid[2]),
          .S02_AXIS_TREADY(eth_tx8_ready[2]),
          .S02_AXIS_TDATA(eth_tx8_data[2]),
          .S02_AXIS_TKEEP(1'b1),
          .S02_AXIS_TLAST(eth_tx8_last[2]),
          .S02_AXIS_TID(3'd2),
          .S02_AXIS_TUSER(eth_tx8_user[2]),

          .S03_AXIS_ACLK(eth_clk),
          .S03_AXIS_ARESETN(~reset_eth),
          .S03_AXIS_TVALID(eth_tx8_valid[3]),
          .S03_AXIS_TREADY(eth_tx8_ready[3]),
          .S03_AXIS_TDATA(eth_tx8_data[3]),
          .S03_AXIS_TKEEP(1'b1),
          .S03_AXIS_TLAST(eth_tx8_last[3]),
          .S03_AXIS_TID(3'd3),
          .S03_AXIS_TUSER(eth_tx8_user[3]),

          .S04_AXIS_ACLK(eth_clk),
          .S04_AXIS_ARESETN(~reset_eth),
          .S04_AXIS_TVALID(1'b0),
          .S04_AXIS_TREADY(),
          .S04_AXIS_TDATA(0),
          .S04_AXIS_TKEEP(1'b1),
          .S04_AXIS_TLAST(1'b0),
          .S04_AXIS_TID(3'd4),
          .S04_AXIS_TUSER(1'b0),

          .M00_AXIS_ACLK(eth_clk),
          .M00_AXIS_ARESETN(~reset_eth),
          .M00_AXIS_TVALID(out_valid),
          .M00_AXIS_TREADY(out_ready),
          .M00_AXIS_TDATA(out_data),
          .M00_AXIS_TKEEP(out_keep),
          .M00_AXIS_TLAST(out_last),
          .M00_AXIS_TID(out_dest),
          .M00_AXIS_TUSER(out_user),

          .S00_ARB_REQ_SUPPRESS(0),
          .S01_ARB_REQ_SUPPRESS(0),
          .S02_ARB_REQ_SUPPRESS(0),
          .S03_ARB_REQ_SUPPRESS(0),
          .S04_ARB_REQ_SUPPRESS(0),

          .S00_FIFO_DATA_COUNT(),
          .S01_FIFO_DATA_COUNT(),
          .S02_FIFO_DATA_COUNT(),
          .S03_FIFO_DATA_COUNT(),
          .S04_FIFO_DATA_COUNT()
      );

      axis_receiver axis_receiver_i (
          .clk  (eth_clk),
          .reset(reset_eth),

          .s_data (out_data),
          .s_keep (out_keep),
          .s_last (out_last),
          .s_user (out_user),
          .s_dest (out_dest),
          .s_valid(out_valid),
          .s_ready(out_ready)
      );
    end
  endgenerate

  wire [7:0] internal_tx_data;
  wire internal_tx_last;
  wire internal_tx_user;
  wire internal_tx_valid;
  assign eth_rx8_data[4]  = internal_tx_data;
  assign eth_rx8_last[4]  = internal_tx_last;
  assign eth_rx8_user[4]  = internal_tx_user;
  assign eth_rx8_valid[4] = internal_tx_valid;

  wire [7:0] internal_rx_data = eth_tx8_data[4];
  wire internal_rx_last = eth_tx8_last[4];
  wire internal_rx_user = eth_tx8_user[4];
  wire internal_rx_valid = eth_tx8_valid[4];
  wire internal_rx_ready;
  assign eth_tx8_ready[4]  = internal_rx_ready;

  // README: internal_tx_* and internal_rx_* are left for internal use.
  // You can connect them with your CPU to transfer frames between the router part and the CPU part,
  // and you may need to write some logic to receive from internal_rx_*, store data to some memory,
  // read data from some memory, and send to internal_tx_*.
  // You can also transfer frames in other ways.
  assign internal_tx_data  = 0;
  assign internal_tx_last  = 0;
  assign internal_tx_user  = 0;
  assign internal_tx_valid = 0;
  assign internal_rx_ready = 0;

  wire [7:0] sfp_led;
  led_delayer led_delayer_i (
      .clk(eth_clk),
      .reset(reset_eth),
      .in_led({
        ~sfp_rx_los[3],
        ~sfp_rx_los[2],
        ~sfp_rx_los[1],
        ~sfp_rx_los[0],
        (eth_tx8_valid[3] & eth_tx8_ready[3]) | eth_rx8_valid[3],
        (eth_tx8_valid[2] & eth_tx8_ready[2]) | eth_rx8_valid[2],
        (eth_tx8_valid[1] & eth_tx8_ready[1]) | eth_rx8_valid[1],
        (eth_tx8_valid[0] & eth_tx8_ready[0]) | eth_rx8_valid[0]
      }),
      .out_led(sfp_led)
  );
  assign {sfp_link, sfp_act} = sfp_led;

  wire [DATA_WIDTH - 1:0] eth_rx_data;
  wire [DATA_WIDTH / 8 - 1:0] eth_rx_keep;
  wire eth_rx_last;
  wire [DATA_WIDTH / 8 - 1:0] eth_rx_user;
  wire [ID_WIDTH - 1:0] eth_rx_id;
  wire eth_rx_valid;

  axis_interconnect_ingress axis_interconnect_ingress_i (
      .ACLK(eth_clk),
      .ARESETN(~reset_eth),

      .S00_AXIS_ACLK(eth_clk),
      .S00_AXIS_ARESETN(~reset_eth),
      .S00_AXIS_TVALID(eth_rx8_valid[0]),
      .S00_AXIS_TREADY(debug_ingress_interconnect_ready[0]),
      .S00_AXIS_TDATA(eth_rx8_data[0]),
      .S00_AXIS_TKEEP(1'b1),
      .S00_AXIS_TLAST(eth_rx8_last[0]),
      .S00_AXIS_TID(3'd0),
      .S00_AXIS_TUSER(eth_rx8_user[0]),

      .S01_AXIS_ACLK(eth_clk),
      .S01_AXIS_ARESETN(~reset_eth),
      .S01_AXIS_TVALID(eth_rx8_valid[1]),
      .S01_AXIS_TREADY(debug_ingress_interconnect_ready[1]),
      .S01_AXIS_TDATA(eth_rx8_data[1]),
      .S01_AXIS_TKEEP(1'b1),
      .S01_AXIS_TLAST(eth_rx8_last[1]),
      .S01_AXIS_TID(3'd1),
      .S01_AXIS_TUSER(eth_rx8_user[1]),

      .S02_AXIS_ACLK(eth_clk),
      .S02_AXIS_ARESETN(~reset_eth),
      .S02_AXIS_TVALID(eth_rx8_valid[2]),
      .S02_AXIS_TREADY(debug_ingress_interconnect_ready[2]),
      .S02_AXIS_TDATA(eth_rx8_data[2]),
      .S02_AXIS_TKEEP(1'b1),
      .S02_AXIS_TLAST(eth_rx8_last[2]),
      .S02_AXIS_TID(3'd2),
      .S02_AXIS_TUSER(eth_rx8_user[2]),

      .S03_AXIS_ACLK(eth_clk),
      .S03_AXIS_ARESETN(~reset_eth),
      .S03_AXIS_TVALID(eth_rx8_valid[3]),
      .S03_AXIS_TREADY(debug_ingress_interconnect_ready[3]),
      .S03_AXIS_TDATA(eth_rx8_data[3]),
      .S03_AXIS_TKEEP(1'b1),
      .S03_AXIS_TLAST(eth_rx8_last[3]),
      .S03_AXIS_TID(3'd3),
      .S03_AXIS_TUSER(eth_rx8_user[3]),

      .S04_AXIS_ACLK(eth_clk),
      .S04_AXIS_ARESETN(~reset_eth),
      .S04_AXIS_TVALID(eth_rx8_valid[4]),
      .S04_AXIS_TREADY(debug_ingress_interconnect_ready[4]),
      .S04_AXIS_TDATA(eth_rx8_data[4]),
      .S04_AXIS_TKEEP(1'b1),
      .S04_AXIS_TLAST(eth_rx8_last[4]),
      .S04_AXIS_TID(3'd4),
      .S04_AXIS_TUSER(eth_rx8_user[4]),

      .M00_AXIS_ACLK(eth_clk),
      .M00_AXIS_ARESETN(~reset_eth),
      .M00_AXIS_TVALID(eth_rx_valid),
      .M00_AXIS_TREADY(1'b1),
      .M00_AXIS_TDATA(eth_rx_data),
      .M00_AXIS_TKEEP(eth_rx_keep),
      .M00_AXIS_TLAST(eth_rx_last),
      .M00_AXIS_TID(eth_rx_id),
      .M00_AXIS_TUSER(eth_rx_user),

      .S00_ARB_REQ_SUPPRESS(0),
      .S01_ARB_REQ_SUPPRESS(0),
      .S02_ARB_REQ_SUPPRESS(0),
      .S03_ARB_REQ_SUPPRESS(0),
      .S04_ARB_REQ_SUPPRESS(0),

      .S00_FIFO_DATA_COUNT(),
      .S01_FIFO_DATA_COUNT(),
      .S02_FIFO_DATA_COUNT(),
      .S03_FIFO_DATA_COUNT(),
      .S04_FIFO_DATA_COUNT()
  );

  // ==================================
  // Datapath
  // ==================================

  wire [DATA_WIDTH - 1:0] dp_rx_data;
  wire [DATA_WIDTH / 8 - 1:0] dp_rx_keep;
  wire dp_rx_last;
  wire [DATA_WIDTH / 8 - 1:0] dp_rx_user;
  wire [ID_WIDTH - 1:0] dp_rx_id;
  wire dp_rx_valid;
  wire dp_rx_ready;

  frame_datapath_fifo #(
      .ENABLE(1),
      .DATA_WIDTH(DATA_WIDTH),
      .ID_WIDTH(ID_WIDTH)
  ) frame_datapath_fifo_i (
      .eth_clk(eth_clk),
      .reset  (reset_eth),

      .s_data(eth_rx_data),
      .s_keep(eth_rx_keep),
      .s_last(eth_rx_last),
      .s_user(eth_rx_user),
      .s_id(eth_rx_id),
      .s_valid(eth_rx_valid),
      .s_ready(debug_datapath_fifo_ready),

      .m_data(dp_rx_data),
      .m_keep(dp_rx_keep),
      .m_last(dp_rx_last),
      .m_user(dp_rx_user),
      .m_id(dp_rx_id),
      .m_valid(dp_rx_valid),
      .m_ready(dp_rx_ready)
  );

  wire [DATA_WIDTH - 1:0] dp_tx_data;
  wire [DATA_WIDTH / 8 - 1:0] dp_tx_keep;
  wire dp_tx_last;
  wire [DATA_WIDTH / 8 - 1:0] dp_tx_user;
  wire [ID_WIDTH - 1:0] dp_tx_dest;
  wire dp_tx_valid;

  reg bram_cpu_clk;
  reg bram_cpu_rst_p;
  assign bram_cpu_clk   = core_clk;
  assign bram_cpu_rst_p = reset_core;
  reg [31:0] bram_cpu_adr;
  reg [31:0] bram_cpu_dat_in;
  reg [31:0] bram_cpu_dat_out;
  reg bram_cpu_wea;
  reg bram_cpu_stb;
  reg bram_cpu_ack;

  logic dma_in_ready, dma_out_ready;
  frame_beat dma_in, dma_out;

  logic dma_cpu_stb, dma_cpu_we;
  logic [31:0] dma_cpu_adr, dma_cpu_dat_width;
  logic dma_ack;
  logic [31:0] dma_dat_width;
  logic [15:0] dma_checksum, dma_checksum_synced;
  logic [1:0] dma_in_port_id, dma_out_port_id;
  logic dma_checksum_valid, dma_checksum_valid_synced;

  logic [127:0] nexthop_ip6_addr;
  logic [4:0] nexthop_addr;
  logic [1:0] nexthop_port_id;

  logic checksum_fifo_in_ready;

  reg dma_stb_delay, dma_we_delay, addr_stb_delay, dm_stb_delay;
  reg nexthop_table_stb_delay, bram_stb_delay, uart_stb_delay, dm_ack_delay;

  axis_data_async_fifo_checksum axis_data_async_fifo_checksum_i (
      .s_axis_aresetn(~reset_core),                // input wire s_axis_aresetn
      .s_axis_aclk   (core_clk),                   // input wire s_axis_aclk
      .s_axis_tvalid (dma_checksum_valid),         // input wire s_axis_tvalid
      .s_axis_tready (checksum_fifo_in_ready),     // output wire s_axis_tready
      .s_axis_tdata  (dma_checksum),               // input wire [15 : 0] s_axis_tdata
      .m_axis_aclk   (eth_clk),                    // input wire m_axis_aclk
      .m_axis_tvalid (dma_checksum_valid_synced),  // output wire m_axis_tvalid
      .m_axis_tready (1'b1),                       // input wire m_axis_tready
      .m_axis_tdata  (dma_checksum_synced)         // output wire [15 : 0] m_axis_tdata
  );


  frame_datapath #(
      .DATA_WIDTH(DATA_WIDTH),
      .ID_WIDTH  (ID_WIDTH)
  ) frame_datapath_i (
      .eth_clk(eth_clk),
      .reset  (reset_eth),

      .s_data(dp_rx_data),
      .s_keep(dp_rx_keep),
      .s_last(dp_rx_last),
      .s_user(dp_rx_user),
      .s_id(dp_rx_id),
      .s_valid(dp_rx_valid),
      .s_ready(dp_rx_ready),

      .m_data (dp_tx_data),
      .m_keep (dp_tx_keep),
      .m_last (dp_tx_last),
      .m_user (dp_tx_user),
      .m_dest (dp_tx_dest),
      .m_valid(dp_tx_valid),
      .m_ready(1'b1),

      // added ip addr and valid
      .ip_addr_0(ip_addrs[0]),
      .ip_addr_1(ip_addrs[1]),
      .ip_addr_2(ip_addrs[2]),
      .ip_addr_3(ip_addrs[3]),

      .mac_addr_0(mac_addrs[0]),
      .mac_addr_1(mac_addrs[1]),
      .mac_addr_2(mac_addrs[2]),
      .mac_addr_3(mac_addrs[3]),

      // README: You will need to add some signals for your CPU to control the datapath,
      // or access the forwarding table or the address resolution cache.

      .cpu_clk(bram_cpu_clk),
      .cpu_rst_p(bram_cpu_rst_p),
      .cpu_adr(bram_cpu_adr),
      .cpu_dat_in(bram_cpu_dat_in),
      .cpu_dat_out(bram_cpu_dat_out),
      .cpu_wea(bram_cpu_wea),
      .cpu_stb(bram_cpu_stb),
      .cpu_ack(bram_cpu_ack),

      // dma interface
      .dma_in(dma_in),
      .dma_in_ready(dma_in_ready),
      .dma_out(dma_out),
      .dma_out_ready(dma_out_ready),

      // rip checksum
      .dma_checksum(dma_checksum_synced),
      .dma_checksum_valid(dma_checksum_valid_synced),

      .nexthop_ip6_addr(nexthop_ip6_addr),
      .nexthop_port_id(nexthop_port_id),
      .nexthop_addr(nexthop_addr),

      // DEBUG signal
      //   .led(led),

      .dma_stb(dma_stb_delay),
      .dma_wea(dma_we_delay),
      .addr_stb(addr_stb_delay),
      .nexthop_table_stb(nexthop_table_stb_delay),

      .dm_stb  (dm_stb_delay),
      .dm_ack  (dm_ack_delay),
      .uart_stb(uart_stb_delay),
      .bram_stb(bram_stb_delay)
  );


  // ==================================
  // CPU
  // ==================================

  // Signals

  logic [4:0] rf_raddr_a, rf_raddr_b, rf_waddr;
  logic [31:0] rf_rdata_a, rf_rdata_b, rf_wdata;
  logic rf_we_p, errno;

  logic [31:0] alu_a, alu_b, alu_y;
  logic [4:0] alu_op;

  logic [31:0] btb_if_pc, btb_id_pc, btb_id_offset, btb_pred_pc;
  logic btb_id_bc, btb_id_we, btb_pred_bc;

  logic [31:0] dm_adr, im_adr;
  logic [31:0] dm_dat_w, dm_dat_r, im_dat_w, im_dat_r;
  logic [3:0] dm_sel, im_sel;
  logic dm_we, dm_stb, dm_ack, dm_err, dm_rty, dm_cyc;
  logic im_we, im_stb, im_ack, im_err, im_rty, im_cyc;

  logic im_fence, dm_fence;


  logic [11:0] csr_addr;
  logic [31:0] csr_data_r;
  logic [31:0] csr_data_w;
  logic csr_we;
  logic csr_error;


  cpu_controller controller_i (
      // Clock and reset
      .clk  (core_clk),
      .rst_p(reset_core),

      // Register file
      .rf_raddr_a(rf_raddr_a),
      .rf_raddr_b(rf_raddr_b),
      .rf_rdata_a(rf_rdata_a),
      .rf_rdata_b(rf_rdata_b),
      .rf_waddr(rf_waddr),
      .rf_wdata(rf_wdata),
      .rf_we_p(rf_we_p),

      // CSR
      .csr_addr_o(csr_addr),
      .csr_data_o(csr_data_w),
      .csr_we_o(csr_we),
      .csr_data_i(csr_data_r),
      .csr_error_i(csr_error),

      // ALU
      .alu_a (alu_a),
      .alu_b (alu_b),
      .alu_op(alu_op),
      .alu_y (alu_y),

      // Data Memory
      .dm_adr_o(dm_adr),
      .dm_dat_o(dm_dat_w),
      .dm_dat_i(dm_dat_r),
      .dm_sel_o(dm_sel),
      .dm_we_o (dm_we),
      .dm_stb_o(dm_stb),
      .dm_ack_i(dm_ack),
      .dm_err_i(dm_err),
      .dm_rty_i(dm_rty),
      .dm_cyc_o(dm_cyc),

      // Instruction Memory
      .im_adr_o(im_adr),
      .im_dat_o(im_dat_w),
      .im_dat_i(im_dat_r),
      .im_we_o (im_we),
      .im_sel_o(im_sel),
      .im_stb_o(im_stb),
      .im_ack_i(im_ack),
      .im_err_i(0),
      .im_rty_i(0),
      .im_cyc_o(im_cyc),

      // fence
      .im_fence_o(im_fence),
      .dm_fence_o(dm_fence),

      // BTB
      .btb_if_pc(btb_if_pc),
      .btb_id_pc(btb_id_pc),
      .btb_id_offset(btb_id_offset),
      .btb_id_bc(btb_id_bc),
      .btb_id_we(btb_id_we),
      .btb_pred_pc(btb_pred_pc),
      .btb_pred_bc(btb_pred_bc)
  );

  register_file register_file_i (
      .clk(core_clk),
      .rst(reset_core),
      .rf_raddr_a(rf_raddr_a),
      .rf_raddr_b(rf_raddr_b),
      .rf_waddr(rf_waddr),
      .rf_wdata(rf_wdata),
      .rf_rdata_a(rf_rdata_a),
      .rf_rdata_b(rf_rdata_b),
      .rf_we_p(rf_we_p),
      .errno(errno)
  );

  csr_file csr_file_i (
      .clk_i(core_clk),
      .rst_i(reset_core),
      .csr_addr_i(csr_addr),
      .csr_data_i(csr_data_w),
      .csr_we_i(csr_we),
      .csr_data_o(csr_data_r),
      .csr_error_o(csr_error)
  );

  alu_comb alu_comb_i (
      .A (alu_a),
      .B (alu_b),
      .OP(alu_op),
      .Y (alu_y)
  );

  btb btb_i (
      .clk(core_clk),
      .rst_p(reset_core),
      .if_pc(btb_if_pc),
      .id_pc(btb_id_pc),
      .id_offset(btb_id_offset),
      .id_wrong(btb_id_bc),
      .id_we(btb_id_we),
      .predict_pc(btb_pred_pc),
      .predict_bc(btb_pred_bc)
  );


  // =======================================
  // Wishbone
  // =======================================

  logic [31:0]
      wbs0_adr,
      wbs1_adr,
      wbs2_adr,
      wbs3_adr,
      wbs4_adr,
      addr_conf_adr,
      nxthop_conf_adr,
      wb_synced_adr;
  logic [31:0]
      wbs0_dat_r,
      wbs0_dat_w,
      wbs1_dat_r,
      wbs1_dat_w,
      wbs2_dat_r,
      wbs2_dat_w,
      wbs3_dat_r,
      wbs3_dat_w,
      wbs4_dat_r,
      wbs4_dat_w,
      addr_conf_dat_r,
      addr_conf_dat_w,
      nxthop_conf_dat_r,
      nxthop_conf_dat_w,
      wb_synced_dat_r,
      wb_synced_dat_w;
  logic [3:0]
      wbs0_sel,
      wbs1_sel,
      wbs2_sel,
      wbs3_sel,
      wbs4_sel,
      addr_conf_sel,
      nxthop_conf_sel,
      wb_synced_sel;
  logic wbs0_we, wbs1_we, wbs2_we, wbs3_we, wbs4_we, addr_conf_we, nxthop_conf_we, wb_synced_we;
  logic
      wbs0_stb,
      wbs1_stb,
      wbs2_stb,
      wbs3_stb,
      wbs4_stb,
      addr_conf_stb,
      nxthop_conf_stb,
      wb_synced_stb;
  logic
      wbs0_ack,
      wbs1_ack,
      wbs2_ack,
      wbs3_ack,
      wbs4_ack,
      addr_conf_ack,
      nxthop_conf_ack,
      wb_synced_ack;
  logic
      wbs0_err,
      wbs1_err,
      wbs2_err,
      wbs3_err,
      wbs4_err,
      addr_conf_err,
      nxthop_conf_err,
      wb_synced_err;
  logic
      wbs0_rty,
      wbs1_rty,
      wbs2_rty,
      wbs3_rty,
      wbs4_rty,
      addr_conf_rty,
      nxthop_conf_rty,
      wb_synced_rty;
  logic
      wbs0_cyc,
      wbs1_cyc,
      wbs2_cyc,
      wbs3_cyc,
      wbs4_cyc,
      addr_conf_cyc,
      nxthop_conf_cyc,
      wb_synced_cyc;

  assign bram_cpu_adr = wbs3_adr;
  assign bram_cpu_dat_in = wbs3_dat_w;
  assign wbs3_dat_r = bram_cpu_dat_out;
  assign bram_cpu_wea = wbs3_we;
  assign wbs3_ack = bram_cpu_ack;
  assign bram_cpu_stb = wbs3_stb;

  logic [22:0] icache_sram_adr, dcache_sram_adr, dma_sram_adr;
  logic [31:0] icache_sram_dat_o, dcache_sram_dat_o, dma_sram_dat_o;
  logic [31:0] icache_sram_dat_i, dcache_sram_dat_i, dma_sram_dat_i;
  logic [3:0] icache_sram_sel, dcache_sram_sel, dma_sram_sel;
  logic icache_sram_we, dcache_sram_we, dma_sram_we;
  logic icache_sram_stb, dcache_sram_stb, dma_sram_stb;
  logic icache_sram_ack, dcache_sram_ack, dma_sram_ack;

  logic [22:0] arbiter_sram_addr;
  logic [31:0] arbiter_sram_data_in;
  logic [31:0] arbiter_sram_data_out;
  logic [ 3:0] arbiter_sram_sel;
  logic        arbiter_sram_we;
  logic        arbiter_sram_cyc;
  logic        arbiter_sram_stb;
  logic        arbiter_sram_ack;

  always_ff @(posedge core_clk) begin
    if (reset_core) begin
      dma_stb_delay <= 1'b0;
      dma_we_delay <= 1'b0;
      addr_stb_delay <= 1'b0;
      nexthop_table_stb_delay <= 1'b0;
      bram_stb_delay <= 1'b0;
      uart_stb_delay <= 1'b0;
      dm_stb_delay <= 1'b0;
      dm_ack_delay <= 1'b0;
    end else begin
      dma_stb_delay <= dma_cpu_stb;
      dma_we_delay <= dma_cpu_we;
      addr_stb_delay <= (addr_stb_delay) ? 1'b1 : addr_conf_stb;
      nexthop_table_stb_delay <= nxthop_conf_stb;
      bram_stb_delay <= bram_cpu_stb;
      uart_stb_delay <= wbs1_stb;
      dm_stb_delay <= dm_stb;
      dm_ack_delay <= dm_ack;
    end
  end

  wb_mux_5 #(
      .DATA_WIDTH  (32),
      .ADDR_WIDTH  (32),
      .SELECT_WIDTH(4)
  ) wb_mux_5_i (
      .clk(core_clk),
      .rst(reset_core),

      // Master interface (Data Memory)
      .wbm_adr_i(dm_adr),
      .wbm_dat_i(dm_dat_w),
      .wbm_dat_o(dm_dat_r),
      .wbm_we_i (dm_we),
      .wbm_sel_i(dm_sel),
      .wbm_stb_i(dm_stb),
      .wbm_ack_o(dm_ack),
      .wbm_err_o(dm_err),
      .wbm_rty_o(dm_rty),
      .wbm_cyc_i(dm_cyc),

      // Slave interface 0 (to data cache, connected to BaseRAM/ExtRAM controller later)
      // Address range: 0x8000_0000 ~ 0x807F_FFFF
      .wbs0_addr    (32'h8000_0000),
      .wbs0_addr_msk(32'hFF80_0000),

      .wbs0_adr_o(wbs0_adr),
      .wbs0_dat_i(wbs0_dat_r),
      .wbs0_dat_o(wbs0_dat_w),
      .wbs0_we_o (wbs0_we),
      .wbs0_sel_o(wbs0_sel),
      .wbs0_stb_o(wbs0_stb),
      .wbs0_ack_i(wbs0_ack),
      .wbs0_err_i('0),
      .wbs0_rty_i('0),
      .wbs0_cyc_o(wbs0_cyc),


      // Slave interface 1 (to UART controller)
      // Address range: 0x1000_0000 ~ 0x1000_FFFF
      .wbs1_addr    (32'h1000_0000),
      .wbs1_addr_msk(32'hFFFF_0000),

      .wbs1_adr_o(wbs1_adr),
      .wbs1_dat_i(wbs1_dat_r),
      .wbs1_dat_o(wbs1_dat_w),
      .wbs1_we_o (wbs1_we),
      .wbs1_sel_o(wbs1_sel),
      .wbs1_stb_o(wbs1_stb),
      .wbs1_ack_i(wbs1_ack),
      .wbs1_err_i('0),
      .wbs1_rty_i('0),
      .wbs1_cyc_o(wbs1_cyc),

      // Slave interface 2 (to DMA adapter)
      // Address range: 0x0100_0000 ~ 0x0100_FFFF
      .wbs2_addr    (32'h0100_0000),
      .wbs2_addr_msk(32'hFFFF_0000),

      .wbs2_adr_o(wbs2_adr),
      .wbs2_dat_i(wbs2_dat_r),
      .wbs2_dat_o(wbs2_dat_w),
      .wbs2_we_o (wbs2_we),
      .wbs2_sel_o(wbs2_sel),
      .wbs2_stb_o(wbs2_stb),
      .wbs2_ack_i(wbs2_ack),
      .wbs2_err_i('0),
      .wbs2_rty_i('0),
      .wbs2_cyc_o(wbs2_cyc),

      // Slave interface 3 (to BRAMs)
      // Address range: 0x2000_0000 ~ 0x2FFF_FFFF
      .wbs3_addr    (32'h2000_0000),
      .wbs3_addr_msk(32'hF000_0000),

      .wbs3_adr_o(wbs3_adr),
      .wbs3_dat_i(wbs3_dat_r),
      .wbs3_dat_o(wbs3_dat_w),
      .wbs3_we_o (wbs3_we),
      .wbs3_sel_o(wbs3_sel),
      .wbs3_stb_o(wbs3_stb),
      .wbs3_ack_i(wbs3_ack),
      .wbs3_err_i('0),
      .wbs3_rty_i('0),
      .wbs3_cyc_o(wbs3_cyc),

      // Slave interface 4 (to Address config and Next-hop config)
      // Address range: 0x4000_0000 ~ 0x4FFF_FFFF
      .wbs4_addr    (32'h4000_0000),
      .wbs4_addr_msk(32'hF000_0000),

      .wbs4_adr_o(wbs4_adr),
      .wbs4_dat_i(wbs4_dat_r),
      .wbs4_dat_o(wbs4_dat_w),
      .wbs4_we_o (wbs4_we),
      .wbs4_sel_o(wbs4_sel),
      .wbs4_stb_o(wbs4_stb),
      .wbs4_ack_i(wbs4_ack),
      .wbs4_err_i('0),
      .wbs4_rty_i('0),
      .wbs4_cyc_o(wbs4_cyc)
  );

  //   cache #(
  //       .BLOCK_WIDTH(2),
  //       .BLOCK_SIZE (4),
  //       .TAG_WIDTH  (17),
  //       .GROUP_NUM  (16),
  //       .GROUP_WIDTH(4),
  //       .GROUP_SIZE (4)
  //   ) cache_IF (
  //       .clk  (core_clk),
  //       .rst_p(reset_core),

  //       .adr_ctl_i (im_adr),
  //       .stb_ctl_i (im_fence || im_stb),
  //       .sel_ctl_i (4'b1111),
  //       .we_p_ctl_i(1'b0),
  //       .ack_ctl_o (im_ack),
  //       .dat_ctl_i (0),
  //       .dat_ctl_o (im_dat_r),

  //       .ack_sram_i (icache_sram_ack),
  //       .stb_sram_o (icache_sram_stb),
  //       .adr_sram_o (icache_sram_adr),
  //       .sel_sram_o (icache_sram_sel),
  //       .we_p_sram_o(icache_sram_we),
  //       .dat_sram_i (icache_sram_dat_i),
  //       .dat_sram_o (icache_sram_dat_o),

  //       .fence(im_fence)
  //   );

  //   cache #(
  //       .BLOCK_WIDTH(2),
  //       .BLOCK_SIZE (4),
  //       .TAG_WIDTH  (17),
  //       .GROUP_NUM  (16),
  //       .GROUP_WIDTH(4),
  //       .GROUP_SIZE (4)
  //   ) cache_MEM (
  //       .clk  (core_clk),
  //       .rst_p(reset_core),

  //       .adr_ctl_i (wbs0_adr),
  //       .stb_ctl_i (dm_fence || wbs0_stb),
  //       .sel_ctl_i (wbs0_sel),
  //       .we_p_ctl_i(wbs0_we),
  //       .ack_ctl_o (wbs0_ack),
  //       .dat_ctl_i (wbs0_dat_w),
  //       .dat_ctl_o (wbs0_dat_r),

  //       .ack_sram_i (dcache_sram_ack),
  //       .stb_sram_o (dcache_sram_stb),
  //       .adr_sram_o (dcache_sram_adr),
  //       .sel_sram_o (dcache_sram_sel),
  //       .we_p_sram_o(dcache_sram_we),
  //       .dat_sram_o (dcache_sram_dat_o),
  //       .dat_sram_i (dcache_sram_dat_i),

  //       .fence(dm_fence)
  //   );

  dma #(
      .IN_DATA_WIDTH (DATAW_WIDTH),
      .OUT_DATA_WIDTH(DATAW_WIDTH)
  ) dma_i (
      .eth_clk(eth_clk),
      .eth_rst(reset_eth),

      .core_clk(core_clk),
      .core_rst(reset_core),

      // Ethernet
      .in(dma_in),
      .in_ready(dma_in_ready),

      .out(dma_out),
      .out_ready(dma_out_ready),

      // SRAM
      .dm_adr_o(dma_sram_adr),
      .dm_dat_o(dma_sram_dat_o),
      .dm_dat_i(dma_sram_dat_i),
      .dm_sel_o(dma_sram_sel),
      .dm_we_o (dma_sram_we),
      .dm_stb_o(dma_sram_stb),
      .dm_ack_i(dma_sram_ack),
      .dm_err_i(1'b0),
      .dm_rty_i(1'b0),
      .dm_cyc_o(),

      // Status Registers
      .cpu_stb_i(dma_cpu_stb),
      .cpu_we_i(dma_cpu_we),
      .cpu_adr_i(dma_cpu_adr),
      .cpu_dat_width_i(dma_cpu_dat_width),
      .cpu_port_id_i(dma_out_port_id),

      .dma_ack_o(dma_ack),
      .dma_dat_width_o(dma_dat_width),
      .dma_checksum_o(dma_checksum),
      .dma_checksum_valid_o(dma_checksum_valid),
      .dma_port_id_o(dma_in_port_id)
  );

  dma_adapter dma_adapter_i (
      .clk(core_clk),
      .rst(reset_core),

      .wbm_adr_i(wbs2_adr),
      .wbm_dat_i(wbs2_dat_w),
      .wbm_dat_o(wbs2_dat_r),
      .wbm_sel_i(wbs2_sel),
      .wbm_we_i (wbs2_we),
      .wbm_stb_i(wbs2_stb),
      .wbm_ack_o(wbs2_ack),

      .dma_ack_i(dma_ack),
      .dma_dat_width_i(dma_dat_width),
      .dma_checksum_i(dma_checksum),
      .dma_port_id_i(dma_in_port_id),

      .dma_port_id_o(dma_out_port_id),
      .dma_cpu_stb_o(dma_cpu_stb),
      .dma_cpu_we_o(dma_cpu_we),
      .dma_cpu_addr_o(dma_cpu_adr),
      .dma_cpu_dat_width_o(dma_cpu_dat_width)

  );


  wb_arbiter_3 #(
      .DATA_WIDTH  (32),
      .ADDR_WIDTH  (23),
      .SELECT_WIDTH(4)
  ) sram_arbiter_i (
      .clk(core_clk),
      .rst(reset_core),

      .wbm0_adr_i(dma_sram_adr),
      .wbm0_dat_i(dma_sram_dat_o),
      .wbm0_sel_i(dma_sram_sel),
      .wbm0_we_i (dma_sram_we),
      .wbm0_cyc_i(dma_sram_stb),
      .wbm0_stb_i(dma_sram_stb),
      .wbm0_ack_o(dma_sram_ack),
      .wbm0_dat_o(dma_sram_dat_i),

      //   .wbm1_adr_i(dcache_sram_adr),
      //   .wbm1_dat_i(dcache_sram_dat_o),
      //   .wbm1_sel_i(dcache_sram_sel),
      //   .wbm1_we_i (dcache_sram_we),
      //   .wbm1_cyc_i(dcache_sram_stb),
      //   .wbm1_stb_i(dcache_sram_stb),
      //   .wbm1_ack_o(dcache_sram_ack),
      //   .wbm1_dat_o(dcache_sram_dat_i),

      .wbm1_adr_i(wbs0_adr),
      .wbm1_dat_i(wbs0_dat_w),
      .wbm1_sel_i(wbs0_sel),
      .wbm1_we_i (wbs0_we),
      .wbm1_cyc_i(wbs0_cyc),
      .wbm1_stb_i(wbs0_stb),
      .wbm1_ack_o(wbs0_ack),
      .wbm1_dat_o(wbs0_dat_r),

      //   .wbm2_adr_i(icache_sram_adr),
      //   .wbm2_dat_i(icache_sram_dat_o),
      //   .wbm2_sel_i(icache_sram_sel),
      //   .wbm2_we_i (icache_sram_we),
      //   .wbm2_cyc_i(icache_sram_stb),
      //   .wbm2_stb_i(icache_sram_stb),
      //   .wbm2_ack_o(icache_sram_ack),
      //   .wbm2_dat_o(icache_sram_dat_i),

      .wbm2_adr_i(im_adr),
      .wbm2_dat_i(im_dat_w),
      .wbm2_sel_i(im_sel),
      .wbm2_we_i (im_we),
      .wbm2_cyc_i(im_cyc),
      .wbm2_stb_i(im_stb),
      .wbm2_ack_o(im_ack),
      .wbm2_dat_o(im_dat_r),

      .wbs_adr_o(arbiter_sram_addr),
      .wbs_dat_i(arbiter_sram_data_in),
      .wbs_dat_o(arbiter_sram_data_out),
      .wbs_sel_o(arbiter_sram_sel),
      .wbs_we_o (arbiter_sram_we),
      .wbs_cyc_o(arbiter_sram_cyc),
      .wbs_stb_o(arbiter_sram_stb),
      .wbs_ack_i(arbiter_sram_ack)
  );


  sram_controller #(
      .SRAM_ADDR_WIDTH(21),
      .SRAM_DATA_WIDTH(32)
  ) sram_controller_base (
      .clk_i(core_clk),
      .rst_i(reset_core),

      // Wishbone slave (from arbiter)
      .wb_cyc_i(arbiter_sram_cyc),
      .wb_stb_i(arbiter_sram_stb),
      .wb_ack_o(arbiter_sram_ack),
      .wb_adr_i(arbiter_sram_addr),
      .wb_dat_i(arbiter_sram_data_out),
      .wb_dat_o(arbiter_sram_data_in),
      .wb_sel_i(arbiter_sram_sel),
      .wb_we_i (arbiter_sram_we),

      // To SRAM chip
      .sram_addr(base_ram_addr),
      .sram_data(base_ram_data),
      .sram_ce_n(base_ram_ce_n),
      .sram_oe_n(base_ram_oe_n),
      .sram_we_n(base_ram_we_n),
      .sram_be_n(base_ram_be_n)
  );

  uart_controller #(
      .CLK_FREQ(125_000_000),
      .BAUD    (115200)
  ) uart_controller (
      .clk_i(core_clk),
      .rst_i(reset_core),

      .wb_cyc_i(wbs1_cyc),
      .wb_stb_i(wbs1_stb),
      .wb_ack_o(wbs1_ack),
      .wb_adr_i(wbs1_adr),
      .wb_dat_i(wbs1_dat_w),
      .wb_dat_o(wbs1_dat_r),
      .wb_sel_i(wbs1_sel),
      .wb_we_i (wbs1_we),

      // to UART pins
      .uart_txd_o(uart_tx),
      .uart_rxd_i(uart_rx)
  );


  // wb async
  wb_async wb_async_i (
      .eth_clk(eth_clk),
      .core_clk(core_clk),
      .eth_reset(reset_eth),
      .core_reset(reset_core),

      // Wishbone Master (to CPU)
      .wbm_adr_i(wbs4_adr),
      .wbm_dat_i(wbs4_dat_w),
      .wbm_dat_o(wbs4_dat_r),
      .wbm_sel_i(wbs4_sel),
      .wbm_we_i (wbs4_we),
      .wbm_stb_i(wbs4_stb),
      .wbm_ack_o(wbs4_ack),

      // Wishbone Slave (to Address Config / Nexthop Table)
      .wbs_adr_o(wb_synced_adr),
      .wbs_dat_i(wb_synced_dat_r),
      .wbs_dat_o(wb_synced_dat_w),
      .wbs_sel_o(wb_synced_sel),
      .wbs_we_o (wb_synced_we),
      .wbs_stb_o(wb_synced_stb),
      .wbs_ack_i(wb_synced_ack)
  );


  // wb async mux
  wb_mux_2 #(
      .DATA_WIDTH  (32),
      .ADDR_WIDTH  (32),
      .SELECT_WIDTH(4)
  ) wb_mux_2_i (
      .clk(eth_clk),
      .rst(reset_eth),

      // Master interface (Data Memory)
      .wbm_adr_i(wb_synced_adr),
      .wbm_dat_i(wb_synced_dat_w),
      .wbm_dat_o(wb_synced_dat_r),
      .wbm_we_i (wb_synced_we),
      .wbm_sel_i(wb_synced_sel),
      .wbm_stb_i(wb_synced_stb),
      .wbm_ack_o(wb_synced_ack),
      .wbm_err_o(),
      .wbm_rty_o(),
      .wbm_cyc_i(wb_synced_stb),

      // Slave interface 0 (to Address Config)
      // Address range: 0x4000_0000 ~ 0x4000_FFFF
      .wbs0_addr    (32'h4000_0000),
      .wbs0_addr_msk(32'hFFFF_0000),

      .wbs0_adr_o(addr_conf_adr),
      .wbs0_dat_i(addr_conf_dat_r),
      .wbs0_dat_o(addr_conf_dat_w),
      .wbs0_we_o (addr_conf_we),
      .wbs0_sel_o(addr_conf_sel),
      .wbs0_stb_o(addr_conf_stb),
      .wbs0_ack_i(addr_conf_ack),
      .wbs0_err_i('0),
      .wbs0_rty_i('0),
      .wbs0_cyc_o(addr_conf_cyc),


      // Slave interface 1 (to Nexthop Config)
      // Address range: 0x4100_0000 ~ 0x4100_FFFF
      .wbs1_addr    (32'h4100_0000),
      .wbs1_addr_msk(32'hFFFF_0000),

      .wbs1_adr_o(nxthop_conf_adr),
      .wbs1_dat_i(nxthop_conf_dat_r),
      .wbs1_dat_o(nxthop_conf_dat_w),
      .wbs1_we_o (nxthop_conf_we),
      .wbs1_sel_o(nxthop_conf_sel),
      .wbs1_stb_o(nxthop_conf_stb),
      .wbs1_ack_i(nxthop_conf_ack),
      .wbs1_err_i('0),
      .wbs1_rty_i('0),
      .wbs1_cyc_o(nxthop_conf_cyc)
  );

  address_config_adapter address_config_adapter_i (
      .eth_clk  (eth_clk),
      .eth_reset(reset_eth),

      .wbm_adr_i(addr_conf_adr),
      .wbm_dat_i(addr_conf_dat_w),
      .wbm_dat_o(addr_conf_dat_r),
      .wbm_sel_i(addr_conf_sel),
      .wbm_we_i (addr_conf_we),
      .wbm_stb_i(addr_conf_stb),
      .wbm_ack_o(addr_conf_ack),

      .ip_addrs (ip_addrs),
      .mac_addrs(mac_addrs)
  );


  nexthop_table_adapter nexthop_table_adapter_i (
      .eth_clk  (eth_clk),
      .eth_reset(reset_eth),

      .r_addr(nexthop_addr),
      .r_nexthop(nexthop_ip6_addr),
      .r_port_id(nexthop_port_id),

      .wbm_adr_i(nxthop_conf_adr),
      .wbm_dat_i(nxthop_conf_dat_w),
      .wbm_dat_o(nxthop_conf_dat_r),
      .wbm_sel_i(nxthop_conf_sel),
      .wbm_we_i (nxthop_conf_we),
      .wbm_stb_i(nxthop_conf_stb),
      .wbm_ack_o(nxthop_conf_ack)
  );


  reg [31:0]im_dat_r_delayed;
  always_ff @(posedge core_clk) begin
    if (reset_core) begin
      im_dat_r_delayed <= 32'h0;
    end else if (im_stb) begin
      im_dat_r_delayed <= im_dat_r;
    end
  end


  reg [31:0]im_adr_delayed;
  always_ff @(posedge core_clk) begin
    if (reset_core) begin
      im_adr_delayed <= 32'd1;
    end else if (im_stb) begin
      im_adr_delayed <= im_adr;
    end
  end


  led_delayer led_delayer_in (
      .clk(eth_clk),
      .reset(reset),
      .in_led(im_adr_delayed[7:0]),
      .out_led(led[7:0])
  );

  led_delayer led_delayer_out (
      .clk(eth_clk),
      .reset(reset),
      .in_led(im_adr_delayed[15:8]),
      .out_led(led[15:8])
  );


  // =======================================
  // Ethernet
  // =======================================

  wire [DATA_WIDTH - 1:0] eth_tx_data[0:4];
  wire [DATA_WIDTH / 8 - 1:0] eth_tx_keep[0:4];
  wire eth_tx_last[0:4];
  wire eth_tx_ready[0:4];
  wire [DATA_WIDTH / 8 - 1:0] eth_tx_user[0:4];
  wire eth_tx_valid[0:4];

  axis_interconnect_egress axis_interconnect_egress_i (
      .ACLK(eth_clk),
      .ARESETN(~reset_eth),

      .S00_AXIS_ACLK(eth_clk),
      .S00_AXIS_ARESETN(~reset_eth),
      .S00_AXIS_TVALID(dp_tx_valid),
      .S00_AXIS_TREADY(debug_egress_interconnect_ready),
      .S00_AXIS_TDATA(dp_tx_data),
      .S00_AXIS_TKEEP(dp_tx_keep),
      .S00_AXIS_TLAST(dp_tx_last),
      .S00_AXIS_TDEST(dp_tx_dest),
      .S00_AXIS_TUSER(dp_tx_user),

      .M00_AXIS_ACLK(eth_clk),
      .M00_AXIS_ARESETN(~reset_eth),
      .M00_AXIS_TVALID(eth_tx_valid[0]),
      .M00_AXIS_TREADY(eth_tx_ready[0]),
      .M00_AXIS_TDATA(eth_tx_data[0]),
      .M00_AXIS_TKEEP(eth_tx_keep[0]),
      .M00_AXIS_TLAST(eth_tx_last[0]),
      .M00_AXIS_TDEST(),
      .M00_AXIS_TUSER(eth_tx_user[0]),

      .M01_AXIS_ACLK(eth_clk),
      .M01_AXIS_ARESETN(~reset_eth),
      .M01_AXIS_TVALID(eth_tx_valid[1]),
      .M01_AXIS_TREADY(eth_tx_ready[1]),
      .M01_AXIS_TDATA(eth_tx_data[1]),
      .M01_AXIS_TKEEP(eth_tx_keep[1]),
      .M01_AXIS_TLAST(eth_tx_last[1]),
      .M01_AXIS_TDEST(),
      .M01_AXIS_TUSER(eth_tx_user[1]),

      .M02_AXIS_ACLK(eth_clk),
      .M02_AXIS_ARESETN(~reset_eth),
      .M02_AXIS_TVALID(eth_tx_valid[2]),
      .M02_AXIS_TREADY(eth_tx_ready[2]),
      .M02_AXIS_TDATA(eth_tx_data[2]),
      .M02_AXIS_TKEEP(eth_tx_keep[2]),
      .M02_AXIS_TLAST(eth_tx_last[2]),
      .M02_AXIS_TDEST(),
      .M02_AXIS_TUSER(eth_tx_user[2]),

      .M03_AXIS_ACLK(eth_clk),
      .M03_AXIS_ARESETN(~reset_eth),
      .M03_AXIS_TVALID(eth_tx_valid[3]),
      .M03_AXIS_TREADY(eth_tx_ready[3]),
      .M03_AXIS_TDATA(eth_tx_data[3]),
      .M03_AXIS_TKEEP(eth_tx_keep[3]),
      .M03_AXIS_TLAST(eth_tx_last[3]),
      .M03_AXIS_TDEST(),
      .M03_AXIS_TUSER(eth_tx_user[3]),

      .M04_AXIS_ACLK(eth_clk),
      .M04_AXIS_ARESETN(~reset_eth),
      .M04_AXIS_TVALID(eth_tx_valid[4]),
      .M04_AXIS_TREADY(eth_tx_ready[4]),
      .M04_AXIS_TDATA(eth_tx_data[4]),
      .M04_AXIS_TKEEP(eth_tx_keep[4]),
      .M04_AXIS_TLAST(eth_tx_last[4]),
      .M04_AXIS_TDEST(),
      .M04_AXIS_TUSER(eth_tx_user[4]),

      .S00_DECODE_ERR()
  );

  generate
    for (i = 0; i < 5; i = i + 1) begin
      egress_wrapper #(
          .DATA_WIDTH(DATA_WIDTH),
          .ID_WIDTH  (ID_WIDTH)
      ) egress_wrapper_i (
          .eth_clk(eth_clk),
          .reset  (reset_eth),

          .s_data (eth_tx_data[i]),
          .s_keep (eth_tx_keep[i]),
          .s_last (eth_tx_last[i]),
          .s_user (eth_tx_user[i]),
          .s_valid(eth_tx_valid[i]),
          .s_ready(eth_tx_ready[i]),

          .m_data (eth_tx8_data[i]),
          .m_last (eth_tx8_last[i]),
          .m_user (eth_tx8_user[i]),
          .m_valid(eth_tx8_valid[i]),
          .m_ready(eth_tx8_ready[i])
      );
    end
  endgenerate
  /*
    led_delayer led_delayer_debug_i1(
        .clk(eth_clk),
        .reset(reset_eth),
        .in_led({1'b0, ~debug_egress_interconnect_ready,
                 ~debug_datapath_fifo_ready,
                 ~debug_ingress_interconnect_ready}),
        .out_led(led[7:0])
    );
    assign led[15:9] = 0;
    */

  // README: DRAM Controller.
  localparam DRAM_READ = 3'b001;
  localparam DRAM_WRITE = 3'b000;

  wire init_calib_complete;
  wire dram_clk, reset_dram;
  wire [28:0] app_addr = 0;
  wire [2:0] app_cmd = DRAM_READ;
  wire app_en = 0;
  wire app_rdy;
  wire [511:0] app_wdf_data = 0;
  wire app_wdf_end = 0;
  wire app_wdf_wren = 0;
  wire [63:0] app_wdf_mask = 0;
  wire app_wdf_rdy;
  wire [511:0] app_rd_data;
  wire app_rd_data_valid;
  generate
    if (!SIM) begin : mig_ip_core
      mig_7series_0 u_mig_7series_0 (
          .ddr3_addr(ddr3_addr),
          .ddr3_ba(ddr3_ba),
          .ddr3_cas_n(ddr3_cas_n),
          .ddr3_ck_n(ddr3_ck_n),
          .ddr3_ck_p(ddr3_ck_p),
          .ddr3_cke(ddr3_cke),
          .ddr3_ras_n(ddr3_ras_n),
          .ddr3_reset_n(ddr3_reset_n),
          .ddr3_we_n(ddr3_we_n),
          .ddr3_dq(ddr3_dq),
          .ddr3_dqs_n(ddr3_dqs_n),
          .ddr3_dqs_p(ddr3_dqs_p),
          .ddr3_cs_n(ddr3_cs_n),
          .ddr3_dm(ddr3_dm),
          .ddr3_odt(ddr3_odt),

          .ui_clk(dram_clk),
          .ui_clk_sync_rst(reset_dram),
          .app_addr({1'b0, app_addr}),
          .app_cmd(app_cmd),
          .app_en(app_en),
          .app_rdy(app_rdy),
          .app_wdf_data(app_wdf_data),
          .app_wdf_end(app_wdf_end),
          .app_wdf_wren(app_wdf_wren),
          .app_wdf_mask(app_wdf_mask),
          .app_wdf_rdy(app_wdf_rdy),
          .app_rd_data(app_rd_data),
          .app_rd_data_end(),
          .app_rd_data_valid(app_rd_data_valid),

          .app_sr_req(1'b0),
          .app_ref_req(1'b0),
          .app_zq_req(1'b0),
          .app_sr_active(),
          .app_ref_ack(),
          .app_zq_ack(),

          .sys_clk_i(mig_clk),
          .clk_ref_i(ref_clk),
          .sys_rst(reset_not_sync),
          .init_calib_complete(init_calib_complete)
      );
    end else begin : mig_model
      assign dram_clk = eth_clk;
      assign reset_dram = reset_eth;
      assign init_calib_complete = 1'b1;

      mig_ui_model mig_ui_model_i (
          .clk  (dram_clk),
          .reset(reset_dram),

          .app_addr(app_addr),
          .app_cmd(app_cmd),
          .app_en(app_en),
          .app_rdy(app_rdy),
          .app_wdf_data(app_wdf_data),
          .app_wdf_end(app_wdf_end),
          .app_wdf_wren(app_wdf_wren),
          .app_wdf_mask(app_wdf_mask),
          .app_wdf_rdy(app_wdf_rdy),
          .app_rd_data(app_rd_data),
          .app_rd_data_end(),
          .app_rd_data_valid(app_rd_data_valid)
      );
    end
  endgenerate
endmodule
